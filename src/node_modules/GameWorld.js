var defaults = require('lodash.defaults');

var TestSphere = require('meshes/TestSphere');
var SkySampler = require('utils/SkySampler');

var DynamicTextureManager = require('textures/DynamicTextureManager');

var __defaultParams = {
	totalTestObjects: 0,
	totalBoxes: 100,
	merge: true
};

function GameWorld(params) {
	params = defaults(params, __defaultParams);
	if(!params.scene) throw new Error('Missing a threejs scene.');
	var scene = params.scene;
	var renderer = params.renderer;

	this.dynamicTextureManager = new DynamicTextureManager({
		renderer: renderer
	});

	var material = new THREE.MeshStandardMaterial({
		map: this.dynamicTextureManager.maps.map.texture,
		normalMap: this.dynamicTextureManager.maps.normalMap.texture,
		emissive: 0xffffff,
		emissiveMap: this.dynamicTextureManager.maps.emissiveMap.texture,
		metalnessMap: this.dynamicTextureManager.maps.metalnessMap.texture,
		roughnessMap: this.dynamicTextureManager.maps.roughnessMap.texture,
		// aoMap: this.dynamicTextureManager.maps.aoMap,
		// alphaMap: this.dynamicTextureManager.passes.alphaMap,
		// alphaTest: 0.5,
		// transparent: true,
		// side: THREE.DoubleSide
	});
	var geometries = [];
	var cols = 2;
	var rows = 2;
	var total = cols * rows;
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.SphereGeometry(0.5, 16, 8);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		geometries.push(geometry);
	}
	for (var i = 0; i < params.totalTestObjects; i++) {
		var geometry = geometries[i % 4];
		var testSphere = new TestSphere({
			geometry: geometry,
			material: material
		});
		testSphere.position.set(
			Math.random() * 10 - 5,
			Math.random() * 10 - 5,
			Math.random() * 10 - 5
		);
		scene.add(testSphere);
		testSphere.castShadow = true;
		testSphere.receiveShadow = true;
	}

	var tileGeometries = [];
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		tileGeometries.push(geometry);
	}
	var boxGeometries = [];
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		boxGeometries.push(geometry);
	}

	var cols = 40;
	var rows = 40;
	var half = cols * 0.5;
	var total = cols * rows;
	var floorMergedGeometry = new THREE.Geometry();
	for (var i = total-1; i >= 0; i--) {
		var row = i % cols;
		var col = ~~(i / cols);
		var floorTile = new THREE.Mesh(
			tileGeometries[~~(Math.random() * tileGeometries.length)],
			material
		);
		floorTile.rotation.x += Math.PI * -0.5;
		scene.add(floorTile);
		floorTile.position.set(row - half + 0.5, 0.05, col - half + 0.5);
		floorTile.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(floorTile);
			scene.remove(floorTile);
		}
	}
	
	var total = params.totalBoxes;
	for (var i = total-1; i >= 0; i--) {
		var box = new THREE.Mesh(
			boxGeometries[~~(Math.random() * boxGeometries.length)],
			material
		);
		scene.add(box);
		while(box.position.length() < 3) {
			box.position.set(
				Math.random() * 20 - 10,
				Math.random() * 20 - 10,
				Math.random() * 20 - 10
			);
		}

		box.castShadow = true;
		box.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(box);
			scene.remove(box);
		}
	}
	

	if(params.merge) {
		var floorMerged = new THREE.Mesh(floorMergedGeometry, material);
		floorMerged.castShadow = true;
		floorMerged.receiveShadow = true;
		scene.add(floorMerged);
		var verts = floorMergedGeometry.vertices;
		var faces = floorMergedGeometry.faces;
		var uvs = floorMergedGeometry.faceVertexUvs[0];
		faces.forEach(function(face){
			var avg = new THREE.Vector3();
			avg.add(verts[face.a]);
			avg.add(verts[face.b]);
			avg.add(verts[face.c]);
			face.dist = avg.length();
		});
		for (var i = uvs.length - 1; i >= 0; i--) {
			uvs[i].dist = faces[i].dist;
		}
		faces.sort(function(a, b) {
			return a.dist - b.dist;
		});
		uvs.sort(function(a, b) {
			return a.dist - b.dist;
		});
	}

	var skyColor = new THREE.Color(0xafbfef);
	var groundColor = new THREE.Color(0x4f3f2f);
	var ambientLight = new THREE.HemisphereLight(skyColor, groundColor);
	skyColor = ambientLight.color;
	groundColor = ambientLight.groundColor;
	scene.add(ambientLight);
	var sunLight = new THREE.DirectionalLight(0xffffaf);
	sunLight.position.set( 0, 100, 100 );
	sunLight.target.position.set( 0, 0, 0 );

	var sky = new THREE.Sky(100);
	sky.uniforms.sunPosition.value = sunLight.position;
	scene.add(sky.mesh);

	var skySampler = new SkySampler({
		renderer: renderer,
		sunPosition: sunLight.position
	});

	var test = new THREE.Mesh(
		new THREE.SphereGeometry(0.5, 16, 8),
		new THREE.MeshBasicMaterial({
			map: skySampler.renderTarget.texture
		})
	);
	test.position.z = -2;
	test.position.y = 1;
	scene.add(test);

	skySampler.createSample(new THREE.Vector3(100, 100, 100), skyColor);
	skySampler.createSample(sunLight.position, sunLight.color);

	sunLight.castShadow = true;
	scene.add(sunLight);

	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFShadowMap;
	this.sunLight = sunLight;
	this.sky = sky;
	this.skySampler = skySampler;
}

function onEnterFrame() {
	this.dynamicTextureManager.update();
	var angle = Date.now() * 0.00002 * Math.PI * 2;
	this.sunLight.position.set(
		Math.cos(angle) * 100,
		Math.sin(angle) * 100,
		0
	);
	this.skySampler.update();
}

GameWorld.prototype = {
	onEnterFrame: onEnterFrame
}

module.exports = GameWorld;