var THREE = require('three');
var defaults = require('lodash.defaults');

var __defaultParams = {
	totalTestObjects: 0,
	totalBoxes: 200,
	merge: true
};

function addTestGeometry(params) {
	params = defaults(params, __defaultParams);
	if(!params.scene) throw new Error('Missing a threejs scene.');

	var scene = params.scene;
	var geometries = [];
	var cols = 2;
	var rows = 2;
	var total = cols * rows;
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.SphereGeometry(0.5, 16, 8);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		geometries.push(geometry);
	}
	for (var i = 0; i < params.totalTestObjects; i++) {
		var geometry = geometries[i % 4];
		var testSphere = new TestSphere({
			geometry: geometry,
			material: params.material
		});
		testSphere.position.set(
			Math.random() * 10 - 5,
			Math.random() * 10 - 5,
			Math.random() * 10 - 5
		);
		scene.add(testSphere);
		testSphere.castShadow = true;
		testSphere.receiveShadow = true;
	}

	var tileGeometries = [];
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		tileGeometries.push(geometry);
	}
	var boxGeometries = [];
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = vert.x * 0.5 + 0.5 * row;
				vert.y = vert.y * 0.5 + 0.5 * col;
			});
		});
		boxGeometries.push(geometry);
	}

	var cols = 40;
	var rows = 40;
	var half = cols * 0.5;
	var total = cols * rows;
	var floorMergedGeometry = new THREE.Geometry();
	for (var i = total-1; i >= 0; i--) {
		var row = i % cols;
		var col = ~~(i / cols);
		var floorTile = new THREE.Mesh(
			tileGeometries[~~(Math.random() * tileGeometries.length)],
			params.material
		);
		floorTile.rotation.x += Math.PI * -0.5;
		scene.add(floorTile);
		floorTile.position.set(row - half + 0.5, 0.05, col - half + 0.5);
		floorTile.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(floorTile);
			scene.remove(floorTile);
		}
	}
	
	var total = params.totalBoxes;
	for (var i = total-1; i >= 0; i--) {
		var box = new THREE.Mesh(
			boxGeometries[~~(Math.random() * boxGeometries.length)],
			params.material
		);
		scene.add(box);
		while(box.position.length() < 3) {
			box.position.set(
				Math.random() * 20 - 10,
				Math.random() * 20 - 10,
				Math.random() * 20 - 10
			);
		}

		box.castShadow = true;
		box.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(box);
			scene.remove(box);
		}
	}
	

	if(params.merge) {
		var floorMerged = new THREE.Mesh(floorMergedGeometry, params.material);
		floorMerged.castShadow = true;
		floorMerged.receiveShadow = true;
		scene.add(floorMerged);
		var verts = floorMergedGeometry.vertices;
		var faces = floorMergedGeometry.faces;
		var uvs = floorMergedGeometry.faceVertexUvs[0];
		faces.forEach(function(face){
			var avg = new THREE.Vector3();
			avg.add(verts[face.a]);
			avg.add(verts[face.b]);
			avg.add(verts[face.c]);
			face.dist = avg.length();
		});
		for (var i = uvs.length - 1; i >= 0; i--) {
			uvs[i].dist = faces[i].dist;
		}
		faces.sort(function(a, b) {
			return a.dist - b.dist;
		});
		uvs.sort(function(a, b) {
			return a.dist - b.dist;
		});
	}
	
}

module.exports = addTestGeometry;