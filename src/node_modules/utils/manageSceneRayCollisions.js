var decorateMethodAfter = require('utils/decorateMethodAfter');

function manageSceneRayCollisions(scene, rayEvents) {
	var objectsWithGetColliders = [];
	var colliders = [];
	var raycaster = new THREE.Raycaster();
	var rayCoord = new THREE.Vector2();
	var ray = raycaster.ray;

	rayEvents.addOnMove(_onMoveOrDrag);
	rayEvents.addOnDrag(_onMoveOrDrag);
	rayEvents.addOnSelect(_onSelect);

	function addColliders(item) {
		if(item.getColliders && objectsWithGetColliders.indexOf(item) === -1) {
			objectsWithGetColliders.push(item);
			var colliders = item.getColliders();
			if(colliders instanceof Array) {
				_addColliders(colliders);
			} else if(colliders) {
				_addCollider(colliders);
			} else {
				throw new Error('No collider!');
			}
		}
	}

	decorateMethodAfter(scene, 'add', addColliders);

	function removeColliders(item) {
		var index = objectsWithGetColliders.indexOf(item);
		if(index !== -1) {
			var item = objectsWithGetColliders.splice(index, 1)[0];
			var colliders = item.getColliders();
			if(colliders instanceof Array) {
				_removeColliders(colliders);
			} else if(colliders) {
				_removeCollider(colliders);
			} else {
				throw new Error('No collider!');
			}
		}
	}
	decorateMethodAfter(scene, 'remove', removeColliders);

	function onEnterFrameUpdateRay(dt) {
		var focusedObject = _getObjectUnderRay();
		if(focusedObject !== this.lastFocusedObject) {
			if(this.lastFocusedObject) {
				this.lastFocusedObject.onOut();
			}
			if(focusedObject) {
				focusedObject.onOver();
			}
			this.lastFocusedObject = focusedObject;
		}
	}
	decorateMethodAfter(scene, 'onEnterFrame', onEnterFrameUpdateRay);


	function _addCollider(collider) {
		if(!collider) {
			throw new Error('collider must be a Mesh.');
		}
		colliders.push(collider);
	}

	function _removeCollider(collider) {
		const index = colliders.indexOf(collider);
		
		if (index !== -1) {
			colliders.splice(index, 1);
		}
	}

	function _addColliders(colliders) {
		colliders.forEach(_addCollider);
	}

	function _removeColliders(colliders) {
		colliders.forEach(_removeCollider);
	}



	function _getObjectUnderRay() {
		ray.origin.set(0, 0, 0);
		var camera = scene.camera;
		camera.localToWorld(ray.origin);
		raycaster.setFromCamera(rayCoord, camera);
		ray.origin.z = camera.far;
		var hit = raycaster.intersectObjects(colliders)[0];
		var focusedObject = hit ? hit.object : null;
		if(focusedObject && focusedObject.collisionOwner) {
			focusedObject = focusedObject.collisionOwner;
		}
		return focusedObject;
	}

	function _onMoveOrDrag(pos) {
		rayCoord.x = pos[0];
		rayCoord.y = pos[1];
	}

	function _onSelect(pos) {
		_onMoveOrDrag(pos);
		var hit = _getObjectUnderRay();
		if(hit && hit.onSelect) {
			hit.onSelect();
		}
	}


}

module.exports = manageSceneRayCollisions;