const colorVertices = require('geometry/utils/colorVertices');

function IconCloseGeometry(params) {
	THREE.Geometry.call(this);

	var radius = params.size * 0.5;

	//cylinder
	var radiusTop = radius - params.thickness;
	var radiusBottom = radius;
	var height = 0;
	var radialSegments = 32;
	var heightSegments = 1;
	var openEnded = true;
	var thetaStart = 0.02 * Math.PI * 2;
	var thetaLength = Math.PI * 1.5;

	var arrowStemGeometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	var arrowStemRotateMatrix = (new THREE.Matrix4()).makeRotationFromEuler(new THREE.Euler(Math.PI * 0.5, 0, 0));
	colorVertices(arrowStemGeometry, params.color);

	this.merge(arrowStemGeometry, arrowStemRotateMatrix);

	var arrowHeadGeom = new THREE.PlaneGeometry(1, 1, 1, 1);
	arrowHeadGeom.vertices[1].set(-0.1, -0.1, 0);
	colorVertices(arrowHeadGeom, params.color);

	var arrowHeadSize = 0.2 * params.size;
	var arrowHeadOffset = (params.size - params.thickness) * -0.5;
	var arrowHeadRotateMatrix = (new THREE.Matrix4()).makeRotationFromEuler(new THREE.Euler(0, 0, Math.PI * 0.25));
	var arrowHeadScaleMatrix = (new THREE.Matrix4()).makeScale(arrowHeadSize, arrowHeadSize, arrowHeadSize);
	var arrowHeadPositionMatrix = (new THREE.Matrix4()).makeTranslation(arrowHeadOffset, 0, 0);
	var arrowHeadMatrix = arrowHeadPositionMatrix.multiply(arrowHeadScaleMatrix).multiply(arrowHeadRotateMatrix);
	this.merge(arrowHeadGeom, arrowHeadMatrix);
}

IconCloseGeometry.prototype = Object.create(THREE.Geometry.prototype);

module.exports = IconCloseGeometry;